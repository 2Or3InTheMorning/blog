# 插入排序（不稳定）

时间复杂度：O(n²)

思路：依次将`无序序列`中的一个记录，按它的大小在`已排序列`中**从后向前扫描**，插入到相应位置。直到所有的记录都插入为止。

```js
 function insertionSort(arr) {
   let preIndex, curValue

   for (let i = 1; i < arr.length; i++) {
     preIndex = i - 1
     curValue = arr[i]
     while (preIndex >=0 && arr[preIndex] > curValue) {
       arr[preIndex + 1] = arr[preIndex]
       preIndex--
     }
     arr[preIndex + 1] = curValue
   }

   return arr
 }
```

大致思想：
  - 一共比较`length - 1`轮，从下标为`1`开始
  - 将数组分为`有序组`、`无序组`（以index=1为“分界线”）
  - 每轮取`无序组`的第一位，赋值temp，开始进行排序
  - 取`有序组`中最后一位的下标，赋值j，记录其下标
  - 将j开始一直递减，为temp找到合适的位置，并将其插入

例子：[1, 9, 7, 6]
  - 一共进行`3`轮，当前`第1轮`
  - 有序组是[1]，无序组是[9, 7, 6]（不是真实数组）
  - 取无序组的第一位(9)，赋值temp（9），开始进行排序，此时数组[1, 9, 7, 6]，temp=9
  - 取`有序组`的最后一位（1）的下标，赋值j，（j=0）
  - 取`有序组`的最后一位（1），它没有比temp（9）大，不换，此时数组[1, 9, 7, 6]，temp=9，j=0
  - 因为到达`有序组`顶端（j=0），将temp（9）放到`有序组（j+1）位`，此时数组[1, 9, 7, 6]，进行`第2轮`
  - 有序组是[1, 9]，无序组是[7, 6]（不是真实数组）
  - 取无序组的第一位(7)，赋值temp（7），开始进行排序，此时数组[1, 9, 7, 6]，temp=7
  - 取`有序组`的最后一位（9）的下标，赋值j，（j=1）
  - `有序组`最后一位（9）比temp（7）大，将`有序组`该位置的数覆盖到下一位，此时数组[1, 9, 9, 6]，temp=7，j=1
  - 再往前看是否有更适合的地方，j--，（j=0）
  - `有序组`第0位（1），它没有比temp（7）大，不换，此时数组[1, 9, 9, 6]，temp=7，j=0
  - 因为到达`有序组`顶端（j=0），将temp（7）放到`有序组（j+1）位`，此时数组[1, 7, 9, 6]，进行`第3轮`
  - 有序组是[1, 7, 9]，无序组是[6]（不是真实数组）
  - 取无序组的第一位(6)，赋值temp（6），开始进行排序，此时数组[1, 7, 9, 6]，temp=6
  - 取`有序组`的最后一位（9）的下标，赋值j，（j=2）
  - `有序组`最后一位（9）比temp（6）大，将`有序组`该位置的数覆盖到下一位，此时数组[1, 7, 9, 9]，temp=6，j=2
  - 再往前看是否有更适合的地方，j--，（j=1）
  - `有序组`第1位（7）比temp（6）大，将`有序组`该位置的数覆盖到下一位，此时数组[1, 7, 7, 9]，temp=6，j=1
  - 再往前看是否有更适合的地方，j--，（j=0）
  - `有序组`第0位（1），它没有比temp（6）大，不换，此时数组[1, 7, 7, 9]，temp=6，j=0
  - 因为到达`有序组`顶端（j=0），将temp（6）放到`有序组（j+1）位`，此时数组[1, 6, 7, 9]，结束排序。
  